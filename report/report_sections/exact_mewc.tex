% ----- Exact Algorithm -----

\section{Exact Algorithm}

% ----- Presentation -----

\subsection{Presentation}

An exact algorithm for solving the MEWC problem works by exploring all potential
cliques in the graph and selecting the clique with the maximum weight. To do this,
the algorithm uses a recursive function to explore all possible subsets of V.
For each subset, the algorithm computes the weight of the clique formed by the
vertices in the subset. If the weight is greater than the current maximum weight,
the clique is selected as the current maximum. This process is repeated until all
possible cliques have been explored, at which point the algorithm returns the
clique the the maximum weight.
\newline \newline
The time complexity of this approach is $\mathcal{O}(n^2\times2^n)$, where $n$ 
is the number of vertices in the graph. This is due to the fact that there are 
$2^n$ possible subsets of V, and the algorithm must compute the weight of the clique, 
which by itself has a complexity of $\mathcal{O}(n^2)$ because there are at most
$\frac{n(n-1)}{2}$ edges in a complete graph, and compare it to the current 
maximum weight. Therefore, the algorithm is only feasible for small-scale graphs.
\newline \newline
However, there is a better algorithm called the \textbf{Bron-Kerbosch}
algorithm\cite{finding-all-cliques-of-an-undirected-graph} that can find all 
maximal cliques in a graph with a time complexity of $\mathcal{O}(3^{\frac{n}{3}})$, 
where $n$ is the number of vertices in the graph. 
This algorithm is optimal, as it has been proven by J. W. Moon \& L. Moser in 
1965\cite{on-cliques-in-graphs} that there are at most $3^{\frac{n}{3}}$ maximal 
cliques in any n-vertex graph.
\newline \newline
We can use the Bron-Kerbosch algorithm to find all maximal cliques in the graph,
and then compute the weight of each clique. This approach has a time complexity of
$\mathcal{O}(n^2\times3^{\frac{n}{3}})$, which is much better than the previous
approach. However, this algorithm is still not feasible for large-scale graphs.

% ----- Fonctionnement -----

\subsection{How it works}

    As said before, our algorithm first uses Bron-Kerbosc to obtain all the maximal cliques of the input graph. Then, it looks for which cliques have the highest weight. So we will explain how it does to get the different maximal cliques. \\

    The Bron-Kerbosch pivot algorithm that we used is a more efficient variant of the Bron-Kerbosch algorithm that is used to find all the cliques in a graph. It works in a similar way to the original Bron-Kerbosch algorithm, but uses a pivot vertex to guide the search for cliques. \\

    At each step of the algorithm, the pivot algorithm keeps track of three groups of vertices: the candidates, which are the set "$P$" of vertices that could potentially be part of the clique, the already-selected vertices, which are the set "$R$" of vertices that are definitely part of the clique, and the set "$X$" of vertices that have been considered but not selected. \\

    The algorithm selects a pivot vertex from the set of candidates and already-selected vertices, and then adds to the candidate set any vertices that are connected to all of the vertices in the already-selected set, as well as the pivot vertex. It then removes from the candidate set any vertices that are not connected to all of the vertices in the already-selected set, and adds those vertices to the set X of vertices that have been considered but not selected. \\

    This process is repeated until the candidate set is empty. At that point, all of the vertices in the already-selected set form a clique. The algorithm is then run again on the remaining candidates and already-selected vertices to find any additional cliques. \\

    We will now illustrate it step by step with a practical example. : \\

    \hspace*{1cm} \textbf{Etape 0 :}
    \\
    \begin{minipage}{0.4\textwidth}
        \begin{tikzcd}
            6 \arrow[r, dash] & 4 \arrow[r, dash] \arrow[dd, dash] & 5 \arrow[dr, dash] \arrow[dd, dash] \\
            & & & 1 \\
            & 3 \arrow[r, dash] & 2 \arrow[ur, dash]
        \end{tikzcd}
    \end{minipage}
    \begin{minipage}{0.6\textwidth}
        We have here our graph as an example. As said before, the Bron-Kerbosh pivot algorithm will take 3 parameters. "R", the set of vertices already selected. "P", the set of candidate vertices. "X", the set of vertices that have been considered but not selected.
    \end{minipage}
    Here, we have :
    $$ \boxed{
            \begin{array}{lll}
                R = \{\} & P = \{1,2,3,4,5,6\} & X = \{\} \\
            \end{array}
    }$$
    \\ 
    \hspace*{1cm}  \textbf{Etape 1 :}
    \\
    \begin{minipage}{0.4\textwidth}
        \begin{tikzcd}
            6 \arrow[r, dash] & 4 \arrow[r, dash] \arrow[dd, dash] & 5 \arrow[dr, dash] \arrow[dd, dash] \\
            & & & 1 \\
            & 3 \arrow[r, dash] & \color{red} 2 \arrow[ur, dash]
        \end{tikzcd}
    \end{minipage}
    \begin{minipage}{0.6\textwidth}
        Now, to begin the algorithm, we will need to chose a pivot $u$. The pivot $u$ should be chosen as one of the degree-three vertices, to minimize the number of recursive calls. Now, we suppose that $u$ is chosen to be vertex 2. We see, that there is 2 verties that are not adjacent to 2 which are 4 and 5.
    \end{minipage}
    Then we know that we will work on these 3 configurations  :
        $$ \boxed{
            \begin{array}{lll}
                R = \{2\} & P = \{1,3,5\} & X = \{\} \\
                R = \{4\} & P = \{3,5,6\} & X = \{\} \\
                R = \{6\} & P = \{\} & X = \{4\} \\
            \end{array}
        }$$
% ----- Pseudo - Code -----

\subsection{Pseudo code}

% ----- Complexit√© -----

\subsection{Complexity}

% ----- Instance -----

\subsection{Instance}

% ----- Experiments -----

\subsection{Experiments}

% ----- Analyse -----

\subsection{Analysis}

\newpage