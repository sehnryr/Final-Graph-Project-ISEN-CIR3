\subsection{How it works}

As said before, our algorithm first uses the Bron-Kerbosch algorithm to obtain
all the maximal cliques of the input graph. Then, it iterate through those maximal
cliques to looks for which cliques have the highest weight. \newline

\textbf{The Bron-Kerbosch pivot algorithm} that we use is a more efficient variant
of the initial algorithm. The basic form of the algorithm is inefficient in the
case of graphs with many non-maximal cliques as it makes a recursive call for
every clique, maximal or not. To save time and allow the algorithm to backtrack
more quickly in branches of the search that contain no maximal cliques, Bron and
Kerbosch introduced a variant of the algorithm involving a "pivot vertex". \newline

At each step, the algorithm keeps track of three groups of vertices: $R$ which is
which is the subset of vertices that must be in a clique, $P$ which is the candidates
that could be included in the clique and $X$ which is the excluded vertices that
already have been searched. In each call of the algorithm, $P$ and $X$ are disjoint
sets whose union consists of vertices that form cliques when added to $R$.
When $P$ and $X$ are both empty there are no further elements that can be added
to $R$, so $R$ is a maximal clique and the algorithm outputs $R$. \newline

The recursion is initiated by setting $R$ and $X$ to be the empty set and $P$ to
be the vertex set of the graph. Within each recursive call, the algorithm considers
the vertices $P$ in turn; if there a no such vertices, it either reports $R$ as
a maximal clique if $X$ is also empty, or continue. Then, a pivot vertex $u$ is
chosen from $P\cup X$ since any maximal clique must include either $u$ or one of
its non-neighbors, for otherwise the clique could be augmented by adding $u$ to it.
Only $u$ and its non-neighbors needs to be tested as the choices for the vertex
$v$ that is added to $R$ in each recusive call to the algorithm. For each vertex
$v$ chosen from $P\backslash N(u)$, with $N(u)$ being the neighbor set of $u$,
it makes a recursive call in which $v$ is added to $R$ and in which $P$ and $X$
are restriced to $N(v)$, which finds and reports all cliques extensions of $R$
that contains $v$. Then, it moves $v$ from $P$ to $X$ to exclude it from consideration
in future cliques and continues with the next vertex in $P\backslash N(u)$. \newline

To illustrate the Bron-Kerbosch algorithm, let's use the example in
Figure \ref{fig:basic-graph-example} on page \pageref{fig:basic-graph-example}:
\newline

\begin{minipage}{\linewidth}
    \textbf{Step 0:} \newline
    \begin{minipage}{0.4\textwidth}
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[node distance=2cm]
                \node (1) {1};
                \node (2) at ([shift=(210:2)] 1) {2};
                \node (3) [left of=2] {3};
                \node (4) [above of=3] {4};
                \node (5) [above of=2] {5};
                \node (6) at ([shift=(150:2)] 4) {6};

                \draw (1) -- (2);
                \draw (1) -- (5);
                \draw (2) -- (3);
                \draw (2) -- (5);
                \draw (3) -- (4);
                \draw (4) -- (5);
                \draw (4) -- (6);
            \end{tikzpicture}
            \caption{Graph illustration for the exact algorithm at step 0}
            \label{fig:exact-mewc-step0}
        \end{figure}
    \end{minipage}
    \begin{minipage}{0.6\textwidth}
        At the initial step, as said before, we will initialize $R$ and $X$ to be the
        empty set and $P$ to be the set of vertices of the graph.

        \begin{center}
            \begin{tabular}{|lll|}
                \hline
                R = \{\} & P = \{1,2,3,4,5,6\} & X = \{\} \\
                \hline
            \end{tabular}
        \end{center}
    \end{minipage}
\end{minipage} \newline

\begin{minipage}{\linewidth}
    \textbf{Step 1:} \newline
    \begin{minipage}{0.4\textwidth}
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[node distance=2cm]
                \node[red] (1) {1};
                \node[Cerulean] (2) at ([shift=(210:2)] 1) {2};
                \node (3) [left of=2] {3};
                \node (4) [above of=3] {4};
                \node[Cerulean] (5) [above of=2] {5};
                \node (6) at ([shift=(150:2)] 4) {6};

                \draw (1) -- (2);
                \draw (1) -- (5);
                \draw (2) -- (3);
                \draw (2) -- (5);
                \draw (3) -- (4);
                \draw (4) -- (5);
                \draw (4) -- (6);
            \end{tikzpicture}
            \caption{Graph illustration for the exact algorithm at step 1}
            \label{fig:exact-mewc-step1}
        \end{figure}
    \end{minipage}
    \begin{minipage}{0.6\textwidth}
        In the first call of the function, since $P$ is not empty, we chose a
        pivot vertex $u$ in $P\cup X$. As it would be more time consuming to
        search for an appropriate pivot vertex, we simply chose the first one
        available, which will be represented in \textcolor{red}{red}. In this 
        example we will always take the first element of $P$. The neighboring
        vertices of $u$ are represented in \textcolor{Cerulean}{blue}. \newline

        After that, we will iterate over the vertices of $P\backslash N(u)$,
        or in this case, $\{1,3,4,6\}$, and for each vertex $v$ we will make a
        recursive call to the function with $v$ added to $R$ and $P$ and $X$
        restricted to $N(v)$, which will find and report all cliques extensions
        of $R$ that contains $v$. \newline
    \end{minipage}
\end{minipage} \newline

\begin{minipage}{\linewidth}
    \textbf{Step 2:} \newline
    \begin{minipage}{0.4\textwidth}
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[node distance=2cm]
                \node[red] (1) {1};
                \node[Cerulean] (2) at ([shift=(210:2)] 1) {2};
                \node (3) [left of=2] {3};
                \node (4) [above of=3] {4};
                \node[Cerulean] (5) [above of=2] {5};
                \node (6) at ([shift=(150:2)] 4) {6};

                \draw (1) -- (2);
                \draw (1) -- (5);
                \draw (2) -- (3);
                \draw (2) -- (5);
                \draw (3) -- (4);
                \draw (4) -- (5);
                \draw (4) -- (6);
            \end{tikzpicture}
            \caption{Graph illustration for the exact algorithm at step 2}
            \label{fig:exact-mewc-step2}
        \end{figure}
    \end{minipage}
    \begin{minipage}{0.6\textwidth}
        At this step, since $P$ is not empty, we will choose a pivot vertex $u$
        in $P\cup X$. Here $u = 2$ and the algorithm will iterate over the
        vertices of $P\backslash N(u)$, which is $\{2\}$. \newline

        The next recursive call will be made with $P = \{5\}$, the pivot vertex
        will be $u = 5$ and then the next recusive call will report the clique
        $\{1,2,5\}$, which will be added to the list of cliques. \newline

        After that, the algorithm will backtrack to $R=\{\}$ since there will be
        no more iteration to do, and will add $1$ to $X$ as is was visited in
        its entirety. \newline

        The recursive call process looks like this:
        \begin{center}
            \begin{tabular}{|lll|}
                \hline
                R = \{1\} & P = \{2,5\} & X = \{\} \\
                R = \{1,2\} & P = \{5\} & X = \{\} \\
                R = \{1,2,5\} & P = \{\} & X = \{\} \\
                \hline
            \end{tabular}
        \end{center}
    \end{minipage}
\end{minipage} \newline

\begin{minipage}{\linewidth}
    \textbf{Step 3:} \newline
    \begin{minipage}{0.4\textwidth}
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[node distance=2cm]
                \node (1) {1};
                \node[Cerulean] (2) at ([shift=(210:2)] 1) {2};
                \node[red] (3) [left of=2] {3};
                \node[Cerulean] (4) [above of=3] {4};
                \node (5) [above of=2] {5};
                \node (6) at ([shift=(150:2)] 4) {6};

                \draw (1) -- (2);
                \draw (1) -- (5);
                \draw (2) -- (3);
                \draw (2) -- (5);
                \draw (3) -- (4);
                \draw (4) -- (5);
                \draw (4) -- (6);
            \end{tikzpicture}
            \caption{Graph illustration for the exact algorithm at step 3}
            \label{fig:exact-mewc-step3}
        \end{figure}
    \end{minipage}
    \begin{minipage}{0.6\textwidth}
        At this step, since $P$ is not empty, we will choose a pivot vertex $u$
        in $P\cup X$. Here $u = 2$ and the algorithm will iterate over the
        vertices of $P\backslash N(u)$, which is $\{2,4\}$. \newline

        The next recursive calls will be made with $P = \{\}$ and $X = \{\}$, so
        they will report the cliques $\{2,3\}$ and $\{3,4\}$, which will be
        added to the list of cliques. \newline

        After that, the algorithm will backtrack to $R=\{\}$ since there will be
        no more iteration to do, and will add $3$ to $X$ as is was visited in
        its entirety. \newline

        The recursive call process looks like this:
        \begin{center}
            \begin{tabular}{|lll|}
                \hline
                R = \{3\} & P = \{2,4\} & X = \{\} \\
                R = \{2,3\} & P = \{\} & X = \{\} \\
                R = \{3,4\} & P = \{\} & X = \{\} \\
                \hline
            \end{tabular}
        \end{center}
    \end{minipage}
\end{minipage} \newline

\begin{minipage}{\linewidth}
    \textbf{Step 4:} \newline
    \begin{minipage}{0.4\textwidth}
        \begin{figure}[H]
            \centering
            \begin{tikzpicture}[node distance=2cm]
                \node (1) {1};
                \node (2) at ([shift=(210:2)] 1) {2};
                \node[Cerulean] (3) [left of=2] {3};
                \node[red] (4) [above of=3] {4};
                \node[Cerulean] (5) [above of=2] {5};
                \node[Cerulean] (6) at ([shift=(150:2)] 4) {6};

                \draw (1) -- (2);
                \draw (1) -- (5);
                \draw (2) -- (3);
                \draw (2) -- (5);
                \draw (3) -- (4);
                \draw (4) -- (5);
                \draw (4) -- (6);
            \end{tikzpicture}
            \caption{Graph illustration for the exact algorithm at step 4}
            \label{fig:exact-mewc-step4}
        \end{figure}
    \end{minipage}
    \begin{minipage}{0.6\textwidth}
        At this step, since $P$ is not empty, we will choose a pivot vertex $u$
        in $P\cup X$. Here $u = 3$ and the algorithm will iterate over the
        vertices of $P\backslash N(u)$, which is $\{5,6\}$. \newline

        The next recursive calls will be made with $P = \{\}$ and $X = \{\}$, so
        they will report the cliques $\{4,5\}$ and $\{4,6\}$, which will be
        added to the list of cliques. \newline

        After that, the algorithm will backtrack to $R=\{\}$ since there will be
        no more iteration to do, and will add $4$ to $X$ as is was visited in
        its entirety. \newline

        The recursive call process looks like this:
        \begin{center}
            \begin{tabular}{|lll|}
                \hline
                R = \{4\} & P = \{5,6\} & X = \{3\} \\
                R = \{4,5\} & P = \{\} & X = \{\} \\
                R = \{4,6\} & P = \{\} & X = \{\} \\
                \hline
            \end{tabular}
        \end{center}
    \end{minipage}
\end{minipage} \newline

The algorithm is therefore \textbf{finished}, and we have obtained the cliques :
$$\{(2,3),(1,2,5),(3,4),(4,5),(5,6)\}$$

To summarize things and try to make things even clearer, we will take another example and make the call tree of it (the precedent example is too big) :

\begin{center}
    \begin{tikzcd}
        1 \arrow[rr, dash] \arrow[dr, dash] & & 3 \arrow[rr, dash] \arrow[dl, dash] & & 4 \\
        & 2 & & 5
    \end{tikzcd}
\end{center}
His call tree :
\begin{center}
    \begin{tikzpicture}[sibling distance=10em, level distance=30mm, every node/.style = {shape=rectangle, draw, align=left, top color=white}]
        \node {
            R = \{\} \\
            P = \{1,2,3,4,5\} \\
            X = \{\}
        }
        child { node {
                        R = \{1\} \\
                        P = \{2,3\} \\
                        X = \{\}
                    }
                child { node {
                                R = \{1,2\} \\
                                P = \{3\} \\
                                X = \{\}
                            }
                        child { node {
                                        R = \{1,2,3\} \\
                                        P = \{\} \\
                                        X = \{\} \\
                                        $\rightarrow$ clique
                                    }
                            }}}
        child { node {
                        R = \{4\} \\
                        P = \{3\} \\
                        X = \{\}
                    }
                child { node {
                                R = \{4,3\} \\
                                P = \{\} \\
                                X = \{\} \\
                                $\rightarrow$ clique
                            }}}
        child { node {
                        R = \{5\} \\
                        P = \{\} \\
                        X = \{\} \\
                        $\rightarrow$ clique
                    }};
    \end{tikzpicture}
\end{center}

After getting every clique, the exact algorithm will iterate all maximal clique and apply a function that will return the total weight of it.
\\ \\
This function work by iterating every possible pairs of vertices in the clique and the weight of it if there is an edge between them in a variable that start at 0. The variable will be returned as the total weight of the clique.
\\ \\
Some quick example of it :
\\ \\
\hspace*{1cm}  \textbf{Step 1 :}

\begin{center}
    Total Weight $= 0$ (start)
\end{center}

\begin{minipage}{0.4\textwidth}
    \begin{tikzcd}
        & \color{red} 1 \arrow[dl, dash, red, "3"] \arrow[dr, dash, "4"] \\
        \color{red} 2 \arrow[rr, dash, "1"] & & 3
    \end{tikzcd}
\end{minipage}
\begin{minipage}{0.6\textwidth}
    The function will take the vertex $1$ and $2$, the edge between them have a weight of $3$. It will add 3 in the variable "Total Weight".
\end{minipage}
\begin{center}
    Total Weight $= 0 + 3 = 3$
\end{center}

\hspace*{1cm}  \textbf{Step 2 :}
\\
\begin{minipage}{0.4\textwidth}
    \begin{tikzcd}
        & 1 \arrow[dl, dash, "3"] \arrow[dr, dash, "4"] \\
        \color{red} 2 \arrow[rr, dash, "1", red] & & \color{red} 3
    \end{tikzcd}
\end{minipage}
\begin{minipage}{0.6\textwidth}
    The function will take the vertex $2$ and $3$, the edge between them have a weight of $1$. It will add 1 in the variable "Total Weight".
\end{minipage}
\begin{center}
    Total Weight $= 3 + 1 = 4$
\end{center}

\hspace*{1cm}  \textbf{Step 3 :}
\\
\begin{minipage}{0.4\textwidth}
    \begin{tikzcd}
        & \color{red} 1 \arrow[dl, dash, "3"] \arrow[dr, dash, red, "4"] \\
        2 \arrow[rr, dash, "1"] & & \color{red} 3
    \end{tikzcd}
\end{minipage}
\begin{minipage}{0.6\textwidth}
    The function will take the vertex $1$ and $3$, the edge between them have a weight of $4$. It will add 4 in the variable "Total Weight".
\end{minipage}
\begin{center}
    Total Weight $= 4 + 4 = 8$
\end{center}

The total weight of this clique is 8.
\\ \\
The algorithm then takes the clique with the greatest weight. And \textbf{the MEWC is solved}.
